% Generated by roxygen2 (4.0.1): do not edit by hand
\docType{data}
\name{regex_supplement}
\alias{regex_supplement}
\title{Supplemental Canned Regular Expressions}
\format{A list with 12 elements}
\usage{
data(regex_supplement)
}
\description{
A dataset containing a list of supplemental, canned regular expressions.  The
regular expressions in this data set are considered useful but have not been
included in a formal function (of the type \code{rm_XXX}).  Users can utilize
the \code{rm_} function to generate functions that can sub/replace/extract as
desired.
}
\details{
The following canned regular expressions are included:
\describe{
  \item{after_a}{single word after the word "a"}
  \item{after_the}{single word after the word "the"}
  \item{after_}{find sing word after ? word (? = user defined); note contains \code{"\%s"} that is replaced by \code{\link[base]{sprintf}} and is not a valid regex on its own}
  \item{before_}{find sing word before ? word (? = user defined); note contains \code{"\%s"} that is replaced by \code{\link[base]{sprintf}} and is not a valid regex on its own}
  \item{hexadecimal}{substring beginning with hash (#) followed by either 3 or 6 select characters (a-f, A-F, and 0-9)}
  \item{ip_address}{substring of four chunks of 1-3 consecutive digits separated with dots (.)}
  \item{split_keep_delim}{regex string that splits on a delimiter and retains the delimiter}
  \item{thousands_separator}{chunks digits > 4 into groups of 3 from right to left allowing for easy insertion of thousands separator; regex pattern retrieved from \href{http://stackoverflow.com/}{StackOverflow}'s stema: \url{http://stackoverflow.com/a/10612685/1000343}}
  \item{time_12_hours}{substring of valid hours (1-12) followed by a colon (:) followed by valid minutes (0-60), followed by an optional space and the character chunk \emph{am} or \emph{pm}}
  \item{white_after_comma}{substring of white space after a comma}
  \item{version}{substring starting with "v" or "version" optionally followed by a space and then period separated digits for <major>.<minor>.<release>.<build>; the build sequence is optional and the "version"/"v" IS NOT contained in the substring}
  \item{version2}{substring starting with "v" or "version" optionally followed by a space and then period separated digits for <major>.<minor>.<release>.<build>; the build sequence is optional and the "version"/"v" IS contained in the substring}
}

Regexes from this data set can be added to the \code{pattern} argument of any
\code{rm_XXX} function via an at sign (@) followed by a regex name from
this data set (e.g., \code{pattern = "@after_the"}) provided the regular
expression does not contain non-regex such as \code{\link[base]{sprintf}}
character string \code{\%s}.
}
\examples{
time <- rm_(pattern="@time_12_hours")
time("I will go at 12:35 pm")

x <- "v6.0.156 for Windows 2000/2003/XP/Vista
Server version 1.1.20
Client Manager version 1.1.24"

rm_default(x, pattern = "@version", extract=TRUE)
rm_default(x, pattern = "@version2", extract=TRUE)

x <- "this is 1000000 big 4356.  And little 123 number."
rm_default(x, pattern="@thousands_separator", replacement="\\\\1,")
rm_default(x, pattern="@thousands_separator", replacement="\\\\1.")

rm_default("I was,but it costs 10,000.", pattern="@white_after_comma",
    replacement=", ")

x <- "I like; the donuts; a lot"
strsplit(x, ";")
strsplit(x, S(grab("split_keep_delim"), ";"), perl=TRUE)
stringi::stri_split_regex(x, S(grab("split_keep_delim"), ";"))

\dontrun{
library(qdap)'library(ggplot2);library(reshape2)

out <- setNames(lapply(c("@after_a", "@after_the"), function(x) {
    o <- rm_default(stringi:::stri_trans_tolower(pres_debates2012$dialogue),
        pattern = x, extract=TRUE)
    m <- qdapTools::matrix2df(data.frame(freq=sort(table(unlist(o)), TRUE)), "word")
    m[m$freq> 7, ]
}), c("a", "the"))


dat <- setNames(Reduce(function(x, y) {
    merge(x, y, by = "word", all = TRUE)}, out), c("Word", "A", "THE"))

dat <- reshape2::melt(dat, id="Word", variable.name="Article", value.name="freq")

dat <- dat[order(dat$freq, dat$Word), ]

ord <- aggregate(freq ~ Word, dat, sum)

dat$word <- factor(dat$Word, levels=ord[order(ord[[2]]), 1])
ggplot(dat, aes(x=freq, y=Word)) + geom_point()+ facet_grid(~Article)
}
}
\keyword{datasets}

